



## 事务隔离



### 1、事务与隔离级别

事务就是要保证一组数据库操作要么全部成功，要不全部失败。mysql的事务支持实在引擎层实现的。有的引擎支持事务，有的引擎不支持事务。MyISAM就不支持事务，innodb支持事务。

当数据库上有多个事务同时执行的时候，就可能出现脏读、不可重复读、幻读等问题。事物的隔离级别就是用来解决这些问题的。隔离的越严实，效率就越低，所以我们要在两者之间找到一个平衡点。sql的隔离级别有：读未提交、读已提交、可重复读、串行化

- 读未提交：还没提交的事务，做出的改动别人可以看到（隔离性很差）
- 读已提交：事务提交之后，做出的改动别人可以看到
- 可重复读：事务执行过程中别人看到的数据总是和这个事务启动时看到的数据是一致的
- 串行化：对同一行记录，读加读锁，写加写锁。读写锁冲突的时候，后来的事务等前一个事务执行完之后再执行

**视图：**

对于读已提交和可重复读，有一个概念叫做视图。在可重复读隔离级别下，视图在事务启动时创建，整个事务存在期间都使用这一个视图。在读已提交隔离级别下，视图是在每个sql语句开始执行的时候创建，所以会有很多版视图。对于读未提交和串行化中没有视图的概念。read-view是事务进行快照读操作的时候产生的读视图。在可重复读的隔离级别下，同一个事务中的第一个快照读会创建read-view，之后的每一次快照读都获取的是同一个read-view。而读已提交的隔离级别下，每个快照读都会生成并获取最新的read-view



### 2、事务隔离的实现

在mysql中，实际上每条记录在更新的时候都会记录一条回滚操作到undo log日志中。被更新的数据通过回滚操作就可以得到前一个状态的值。

eg：在一个事务中，把1依次改成2、3、4

![image-20230415095402504](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230415095402504.png)



对于同一条记录，不同时刻启动的事务有不同的是read-view，如图所示在视图A、B、C中，这条记录的值分别是1，2，4，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。对于read-view A，要得到1，就必须将当前值依次执行图中所有回滚操作得到。

建议尽量不要使用长事务。使用长事务意味着系统中会存在很老的事务视图。由于这些事务随时可能存在访问数据库里面的任何数据，所以这个事务提交之前，它对应的所有回滚记录都要保存着，这样reaad-view就会占用很大的存储空间。所以我们建议不要启动长事务，爆炸了



### 3、事务的启动方式

事务有两种启动方式

1、显式的启动，用命令`begin`或者`start transaction` ，配套的提交语句是`commit`，回滚语句是`rollback` 

```
		START TRANSACTION;
		事务代码
		commit;
```

2、使用`set autocommit=0` ，这个命令会将线程的自动提交关掉，也就是说只执行一个select语句事务就启动了，并且不会自动提交。这个事务将会持续存在直到你主动执行commit或者rollback语句，或者断开连接，也就是我们上面说的启动了一个长事务，所以最好按照`set autocommit=1`  的方式来显式启动事务

```
show VARIABLES like 'autocommit';
```

执行结果如图所示：结果为ON表示自动提交已经打开

![image-20230415103950594](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230415103950594.png)

给它关了：

![image-20230415104208220](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230415104208220.png)



但是对于频繁使用事务的业务，如果疯狂开关开关事务也会造成多一次交互的问题，这样的情况我们建议使用`commit work and chain` 语法来提交事务，这条语句的意思是提交事务并启动下一个事务，这样省去了begin的开销，也避免了使用长事务



## 索引

索引的出现就是为了提高查询效率，就像书的目录。实现索引的方式有很多，其中比较常见的有哈希表、有序数组、搜索树。

### 1、实现模型

#### 哈希表

哈希表适合等值查询的场景，如果是范围查询直接寄。适用于一些NoSQL的场景。对于insert一条数据也是非常的适合，因为存的时候不是有序的，无序的话插入一条新数据的时候就不需要考虑顺序。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

如果经过哈希算法得到的hashCode值一样的话，会用一个链表把这两个值拉在后面：

![image-20230415120401128](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230415120401128.png)



#### 有序数组

有序数组在等值查询和范围查询场景中非常优秀

![image-20230415121019295](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230415121019295.png)

等值查找的时候用的是二分，复杂度是O(log(N))，范围查找的时候，还是用二分找到范围的起始，然后循环到范围的末尾，时间复杂度还算是O(log(N))。但是插入一条新数据的时候就寄了，因为数组是有序的，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以有序数组索引只适用于静态存储引擎



#### 二叉搜索树

二叉搜索树的特征是：每个结点的左子结点小于父结点，父结点小于右子结点。在下边的二叉树中，如果想找到user2的话，搜索顺序是：

useA-》useC-》useF-》use2，每次进入父结点的时候判断一下target是大于父结点还是小于父结点，如果是大于走右边，小于走左边。时间复杂度O(log(N))。要维持这棵树是平衡二叉树，更新的时间复杂度也是O(log(N))。

![image-20230415121920118](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230415121920118.png)

二叉搜索的效率确实高，但是实际上数据库的存储不会使用二叉树，原因是索引不仅要写到内存中，还要写进磁盘上。如果一个树结点一大堆，高度又高，每次访问一行数据的时候，都要去磁盘里查找一次，一次10ms，寄。

为了让查询尽量少的访问磁盘，我们把二叉树改成N叉树。N叉树由于读写性能优势，已经被广泛应用在数据库引擎中了。

mysql中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引实现不一样。



### 2、InoDB的索引模型

innodb在mysql中用的多一些，innodb存储引擎的索引实现用的是b+树。每一个索引在innodb中对应一棵B+树。innodb中的索引分为主键索引和非主键索引。**主键索引的叶子节点的内容是整行数据**，主键索引也称为聚簇索引。**非主键索引的叶子节点的内容是主键的值**，非主键索引又称为二级索引

基于主键索引和普通索引查询区别

对于语句`select * from T where ID=500`，我们会直接去ID主键索引的B+树里去找。对于语句` select * from T where k=5` ，我们会去搜索k的索引树，所处来拿到主键ID，再拿着ID去ID索引树里去搜一遍，**这个过程叫做回表** 。也就是说，使用非主键索引需要多扫描一棵索引树，因此我们在应用中应该多使用主键查询

索引维护

如果说我们插入新的一行数据，那么为了保证原来索引树的有序性，我们需要考虑新的数据的插入位置，但是如果我们**将表的主键设置为自增**的，在插入一条新数据的时候，就是以追加的形式插入表中的，系统会获取当前ID最大值加1作为下一条新数据的ID值。但是如果用的是具有业务逻辑的字段作为主键，则不容易保证有序插入，这样写数据成本比较高。所以，从性能和存储空间方面考量，自增主键更合适。另外，我们如果直接将自增主键设置为索引，可以避免每次查询要搜索两棵树。

```
NOT NULL PRIMARY KEY AUTO_INCREMENT
```

