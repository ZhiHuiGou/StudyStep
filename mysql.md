# mysql







# 一条查询sql语句是怎么执行的



### 1、了解执行过程之前先看一下mysql服务器的架构：

![image-20230414121702252](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230414121702252.png)

mysql服务器分为<u>两层</u>，分别是<u>server层和存储引擎层</u> 

server层涵盖大多数的mysql核心功能，存储引擎层则是负责数据的存储和提取。存储引擎有很多种，mysql默认的存储引擎是innoDB，也就是说在建表的时候如果不指定这张表的存储引擎，mysql会自动帮我们设置为innodb。

不同的存储引擎共用一个server层 

### 2、各个组件

#### 1、连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接

完成TCP握手之后，服务端与客户端建立连接，连接器就要确认你的身份，这时你需要输入用户名密码，不正确的话返回"Access denied for user"错误，正确的话连接器去权限表中查出你拥有的权限，之后这个连接里的权限判断逻辑都依赖于此时读到的权限

连接完成之后，如果你没有后续操作，连接器会自动将这个连接断开，这个等待时间是由参数wait_timeout控制的，默认值是8小时。

数据库的连接分为两种，一种长连接，一种短连接。长连接指每次都用这一个连接，短连接是指每次执行少数的查询就断开，下次查询再重新建立一个连接。建议使用长连接。但是会发现使用长连接mysql占用的内存涨的非常快，mysql会异常重启。我们可以定期断开长连接

#### 2、查询缓存

mysql5.7有这个功能，后面没有了。不建议整这个，利大于弊，查询缓存中的数据失效率很高，命中率低，除非业务是一张静态表，基本上不怎么变的那种。

当mysql拿到一个查询命令的时候，会先到缓存中（key-value形式）看看有没有执行过这条语句，如果执行过，返回value给客户端。如果缓存中没有就继续向下执行

#### 3、分析器

这一步mysql要知道你要干什么

分析器执行两步，一步是词法分析，一步是语法分析

先做词法分析，先分析出来是什么语句（DDL / DQL等等），表名，列ID都确认下来

再做语法分析，根据语法规则判断输入的sql语句是否满足mysql的语法

```
mysql> elect * from t where ID=1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that correspo
```

#### 4、优化器

在执行语句之前，要先经过优化器进行处理。当表里有多个索引时，决定使用哪个索引；一个语句中有多表关联的时候，决定先查哪个表

```
mysql> select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
```

比如说这条语句，多表查询，有t1和t2两个表，是先查t1还是先查t2由优化器来决定。这两种查法的逻辑结果是一样的，但是执行效率不同

优化器执行完之后，语句的执行方案就确定了，然后进入执行器阶段

#### 5、执行器

执行之前，要先判断一下你对这个表有咩有执行的权限，如果或没有就会返回没有权限的错误。如果有的话，执行器就会根据表的存储引擎去调用对应引擎提供的接口

执行的逻辑基本上都是：

①第一次调用取第一行数据，判断是否满足要求，如果满足将这行数据存入结果集，如果不满足跳过

②之后调用引擎接口取“下一行”，重复调用取下一行的接口

③执行器将遍历过程中所有满足条件的行组成的记录集返回给客户端



## 一条sql更新语句是如何执行的

### 1、update语句执行流程

一条update语句的执行也是按照查询语句的流程走一遍的。但是之前提到的查询缓存，一旦一个表中的数据有更新，关于这张表的查询缓存就会清空，所以这条语句会把对应的表上的缓存结果都清空

接下来，分析器对该语句进行分析，知道这条语句是一条更新语句。然后优化器确定索引。接着是执行器负责具体执行，找到这一行，进行更新

与查询不同的地方在于更新的流程涉及两个重要的日志模块，分别是redo log（重做日志）和bin log（归档日志）



### 2、redo log

如果每次的更新操作都需要写入磁盘，那么IO成本、查找成本都很高，所以mysql技术中出现了WAL技术，它的关键在于先写日志，再写磁盘。也就是当有一条数据需要更新的时候，InnoDB存储引擎会先将记录写道redo log里并更新内存，之后在适当的时候innodb再将这个记录更新到磁盘中，这个更新操作往往是系统比较空闲的时候

innoDb的redo log大小是固定大小的，配置了一个4G大的redo log文件，从头开始写，写到末尾就回到开头循环写

图中的write pos记录当前位置，check point记录是已经持久化到的位置。当write pos追上check point就说明redo log文件已经写满了。check point减去write pos就是可以写的日志大小

![image-20230414164829965](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230414164829965.png)



### 2、bin log

mysql架构由两部分，一部分是server，一部分是存储引擎。其中redo log是存储引擎的innodb所特有的一种功能。而bin log是server层的日志文件

他俩的区别：

1、redo log是innodb引擎特有的：bin log是mysql的server层实现的，所有引擎都可以使用

2、redo log是物理日志，bin log是逻辑日志

3、redo log是循环写，空间大小固定，会用完。bin log是“追加写”，bin log文件到一定大小会切换一个新的日志文件，不会覆盖以前的日志



3、执行器和innodb执行update语句时的内部流程

```
mysql> update T set c=c+1 where ID=2;
```

①执行器找引擎取ID=2这一行，如果ID=2这一行本来就在内存中，直接返回给执行器，否则需要此案从磁盘读入内存再返回给执行器

②执行器拿到引擎给的数据，把值加1得到新的一行数据，再调用引擎接口将新的一行数据写入

③引擎将这行数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于prepare状态然后告知执行器执行完了，随时可以提交事务

④执行器生成这个操作的binlog，并把binlog写入磁盘

⑤执行器调用引擎的提交事务接口，引擎把刚刚写入redo log改成commit状态

（到此，update语句执行完成）

![image-20230414171034880](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/image-20230414171034880.png)



注意这里的写入日志是分两阶段提交的，是因为这样可以防止数据丢失导致日志中的数据与原库中不同
