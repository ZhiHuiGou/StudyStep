# JVM

## 基本概念



## Java内存区域详解

### 总述

Java程序员把内存控制权交给Java虚拟机，，不会轻易出现内存泄漏或者内存溢出，但是如果一旦出现这样的问题，不了解虚拟机是怎样运行的话，排查错误将是一个非常艰巨的任务

Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域

- jdk1.8之前：

![](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/java-runtime-data-areas-jdk1.7.png)



- jdk1.8之后

![Java 运行时数据区域（JDK1.8 之后）](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/java-runtime-data-areas-jdk1.8.png)

**线程私有的**：

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的**：

- 堆
- 方法区
- 直接内存（非运行时数据区域的一部分）



Java虚拟机规范对于运行时数据区域的规定相当宽松。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需要扩展。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的

### 概述

### 1、程序计数器

程序计数器是一块较小的内存空间，可以看作房钱线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存

从上面两段，我们知道了线程计数器主要又两个作用：

- 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
- 在多线程的情况下，程序计数器用于记录当前程序执行的位置，从而当线程被切换回来的时候就能够知道该线程上次运行到哪里了

注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡

### 2、Java虚拟机栈

于程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程一眼给，随着线程的创建而创建，随着线程的死亡而死亡

栈算是JVM运行时数据区域的一个核心，除了一些native方法调用时通过本地方法栈实现的，其他所有的Java方法调用都是通过栈来实现的

方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每个方法调用结束后，都会有一个栈帧被弹出

栈由一个个栈帧组成，而每个栈帧中都有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者哦都是先进先出的数据结构，只支持出栈和入栈两种操作

![Java 虚拟机栈](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/stack-area.png)

#### 1、局部变量表

主要存放了编译期可以的各种数据类型（boolean、byte、char、short、int、float、long、double）、引用类型（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针）

这些数据类型在局部变量变量表中的存储空间以局部变量槽来标识。其中64位的double和long会占用两个变量槽，其它类型的数据占用一个变量槽

局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间都是正确的，方法运行期间不会改变局部变量的大小

虚拟机真正使用多大的内存空间来实现一个变量槽，这是由具体的虚拟机实现自行决定的事情

![局部变量表](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/local-variables-table.png)

#### 2、操作数栈

主要作为方法调用的<u>中转站</u>使用，用于存放<u>方法执行过程中产生的中间计算结构</u>。另外，计算过程中产生的<u>临时变量</u>也会放在操作数栈中



#### 3、动态链接

主要服务一个方法需要调用其他方法的场景。在Java源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用保存在Class文件的常量池中。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址钟大哥直接引用。

动态链接的作用就是为了将符号引用转换为调用方法的直接引用

![img](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/jvmimage-20220331175738692.png)

栈空间虽然不是无限的，但一般正常调用的情况下不会出现问题，不过如果函数低矮哦用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求站的深度超过当前Java虚拟机栈的最大深度的时候，就会抛出`StackOverFlowError`错误

Java方法有两种返回方式，一种是return语句正常返回，一种是抛异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说，栈帧随着方法调用而创建，随着方法结束而销毁。无论是正常完成还是一场完成都算作方法结束

还有一种异常很常见：`OutOfMemoryError`如果栈的内存大小可以动态扩展，如贵哦虚拟机在动态扩展栈式五发生青岛足够的内存空间，则抛出`OutOfMemoryError` 



### 3、本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的本地（Native）方法服务。在HotSopt虚拟机中和Java虚拟机栈合二为一



### 4、堆

Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**

Java中所有的对象都在堆中分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也不是那么绝对了。从jdk1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者违背外面使用，那么对象可以直接在栈上分配内存

Java堆是垃圾回收器管理的主要区域，因此也被称为GC堆。从垃圾回收角度，由于现在收集器基本上都采用分代垃圾收集算法，所以Java堆中经常出现“新生代”、“老年代”、“永久代”、“Eden空间”、“From Survivor空间”、“To Survivor空间”等名词。这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格，并非某个Java虚拟机具体实现的固有内存分布。如果是十年前，作为主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，者们说没有太大歧义。但是在今天，垃圾回收器技术与十年前已经不一样了，HotSpot里面也出现了不采用分代设计的新垃圾回收器，再按照上面提到的划分就不合适了

从内存分配的角度来看，所有线程共享的Java可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。Java堆中存储的内容共性不会变，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快的分配内存。

Java堆可以处于物理上的不连续内存空间中，但在逻辑上，他应该被视为连续的。因为对于大的对象（典型的是数组对象），多数的虚拟机实现出于简单、存储高效的考虑，很可能会要求连续的内存空间

Java堆既可以被实现成固定大小的，也可以是可扩展的。当前的主流Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）



### 5、方法区

方法区属于JVM运行时数据区域的一块逻辑区域，是各个线程共享内存区域。Java虚拟机规范只给出了方法区这个概念和作用，方法区具体要怎么实现就是虚拟机自己要考虑的事情了，也即是说，不同的虚拟机上，方法区的实现是不同的

当虚拟机要使用一个类的时候，它需要读取并解析Class文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量，即时编译器编译后的代码缓存等数据

方法区和永久代以及元空间是什么关系呢？方法区和永久代/元空间的关系就像Java中的接口和实现类的关系

![HotSpot 虚拟机方法区的两种实现](https://typora--cr--images.oss-cn-beijing.aliyuncs.com/method-area-implementation.png)

- 在jdk1.8之前，HotSpot虚拟机的方法去实现就用的是永久代，并且HotSpot的使用量很大，所以大家就把永久代和方法区混为一谈。实际上方法区和永久代并不等价。HotSpot的设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区，这样使得HotSpot的垃圾回收器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。这样的设计方式实际上并不好，导致了Java应用更容易遇到内存溢出的问题。
- 但是对于其他虚拟机来说，没有永久代这个概念。实际上很少有Java中的方法会因为永久区的问题在不同的虚拟机上有不同的表现，所以Oracle收购了BEA获得了JRockit虚拟机的所有权之后，决定把JRockit的优秀功能移植到HotSpot中，但是一次性合并比较困难，所以从jdk6开始到8，逐步将JRockit优秀功能移植到HotSpot中
- jdk8之后，方法区的实现方式完全变成元空间。



相对而言，垃圾回收这个行为在方法区是比较少出现的。Java虚拟机对于方法区的约束比较少，可以选择不实现垃圾回收，但是并不是数据一进入方法区就永久存在了，该区域的内存回收目标主要是针对常量池的回收和对类型的写在，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收又是必要的。



**方法区常用的参数有哪些？**

jdk8之前：

```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```

jdk8之后：

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```



### 运行时常量池

运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译器生成的各种字面量和符号引用的**常量池表**



















































































































